#include <iostream>
#include <fstream>

#include <algorithm>
#include <vector>
#include <map>
#include <deque>

using namespace std;

struct mmBlock
{
    int blockNumber = 0;
    int tag = 0;
    int index = 0;
    int data = 0;
};

struct cacheBlock
{
    int blockNumber = 0;
    int dirtyBit = 0;
    int validBit = 0;
    int tag = 0;
    string data;
    deque<int> fifoQueue; //first block in a cache set will contain the queue for the whole set
    deque<int> lruQueue;  //first block in a cache set will contain the queue for the whole set
};

struct memoryReference
{
    /* objects to be contained in the reference table
    */
    int memoryAddress = 0;
    int mmBlock = 0;
    int cmSet = 0;
    string cmBlock;
    string hitMiss;
};

int countBits(int block_size)
{
    //counts the bits needed to represent an integer
    int count = 0;
    while (block_size)
    {
        count++;
        block_size = block_size >> 1;
    }
    return count;
}

vector<int> possibleBlocks(int set, int setDegree)
{
    //returns possible cache blocks given a cache set and the set degree
    vector<int> possibleBlocks;
    for (int i = 0; i < setDegree; i++)
    {
        possibleBlocks.push_back(set * setDegree + i);
    }
    return possibleBlocks;
}

void clearCacheBlock(int cmBlock, map<int, cacheBlock> &cacheTable)
{
    //clears a given cache block in the cache table
    cacheTable[cmBlock].validBit = 0;
    cacheTable[cmBlock].tag = 0;
    cacheTable[cmBlock].data.erase();
}

void updateCacheTable(int cmBlock, int memoryBlock, int tag, map<int, cacheBlock> &cacheTable)
{
    //given a cache block, memory block, tag, and the cache table, updates the cache table with a new value
    cacheTable[cmBlock].validBit = 1;
    cacheTable[cmBlock].tag = tag;
    cacheTable[cmBlock].data.append("mm blk # ");
    cacheTable[cmBlock].data.append(to_string(memoryBlock));
}

void printReferenceTable(map<int, memoryReference> referenceTable)
{
    cout << "main memory address   "
         << "mm blk #   "
         << "cm set #   "
         << "cm blk #   "
         << "hit/miss" << endl;
    for (int i = 0; i < referenceTable.size(); i++)
    {
        cout << "       " << referenceTable[i].memoryAddress;
        cout << "                  " << referenceTable[i].mmBlock;
        cout << "         " << referenceTable[i].cmSet;
        cout << "       " << referenceTable[i].cmBlock;
        cout << "       " << referenceTable[i].hitMiss << endl;
    }
}

void printCacheTable(map<int, cacheBlock> cacheTable)
{
    cout << "Cache blk #   "
         << "dirty bit   "
         << "valid bit   "
         << "tag   "
         << "Data" << endl;
    for (int i = 0; i < cacheTable.size(); i++)
    {
        cout << "       " << cacheTable[i].blockNumber;
        cout << "          " << cacheTable[i].dirtyBit;
        cout << "          " << cacheTable[i].validBit;
        if (cacheTable[i].validBit == 1)
        {
            cout << "         " << cacheTable[i].tag;
            cout << "    " << cacheTable[i].data << endl;
        }
        else
        {
            cout << "         xxx";
            cout << "    xxx" << endl;
        }
    }
}
int main()
{
    // // 4 bytes minimum to 32Kbytes maximum
    int mmSize = 128;
    // cout << "Enter the size of main memory in bytes:";
    // cin >> mm_size;

    // // 2 bytes minimum to 32Kbytes maximum
    int cacheSize = 32;
    // cout << "Enter the size of the cache in bytes:";
    // cin >> cache_size;

    // // 2 bytes minimum to 32Kbytes maximm
    int blockSize = 4;
    // cout << "Enter the cache block/line size:";
    // cin >> block_size;

    int setDegree = 4;
    // cout << "Enter the degree of set-associativity (input n for an n-way set-associative mapping):";
    // cin >> set_degree;

    // // at start up assume lower cm block numbers are LRU than cm blocks with higher numbers.
    string replacement_policy = "F";
    // cout << "Enter the replacement policy (L = LRU, F = FIFO):";
    //cin >> replacement_policy;

    string input_file;
    // cout << "Enter the name of the input file containing the list of memory references generated by the CPU:";
    // cin >> input_file;
    int mmBlocks = mmSize / blockSize;       //max amount of memory blocks
    int cacheBlocks = cacheSize / blockSize; //max amount of cache blocks
    int cacheSets = cacheBlocks / setDegree; //max amount of cache sets

    //# of bits for offset
    int offsetBits = countBits(blockSize - 1);
    //# of bits for the index ()
    int indexBits = countBits(cacheSets - 1);
    //#of bits for the tag()
    //cout << mmBlocks << " " << cacheSets << endl;
    //MAKE SURE THIS ISNT -1
    int tagBits = countBits((mmBlocks / cacheSets) - 1);
    //total cache size in bytes (valid bit + dirty bit + tag_size + bytes of data)
    int totalCacheSize = mmBlocks + 2 + tagBits;
    //address lines required (tag + index + offset)
    int addressLines = indexBits + tagBits + offsetBits;

    cout << "Total address lines required = " << addressLines << endl;
    cout << "Number of bits for offset = " << offsetBits << endl;
    cout << "Number of bits for index = " << indexBits << endl;
    cout << "Number of bits for tag = " << tagBits << endl;
    cout << "Total cache size required = " << totalCacheSize << " bytes" << endl;

    //create a blank cache table(all values are 0)
    map<int, cacheBlock> cacheTable;
    for (int i = 0; i < cacheBlocks; i++)
    {
        cacheBlock newBlock;
        newBlock.blockNumber = i;
        cacheTable[i] = newBlock;
    }

    //create the main memory table(sets up tag, index and block number)
    map<int, mmBlock> mmTable;
    int tag = 0;
    int index = 0;
    for (int i = 0; i < mmBlocks; i++)
    {
        if (i % cacheSets == 0 && i != 0)
        {
            tag++;
            index = 0;
        }
        mmBlock newBlock;
        newBlock.blockNumber = i;
        newBlock.tag = tag;
        newBlock.index = index;
        mmTable[i] = newBlock;
        index++;

        // cout << mmTable[i].blockNumber << " " << mmTable[i].tag << " " << mmTable[i].index << endl;
    }

    ifstream inFile("input_file1.txt");
    string file_text;

    //dont really care about the first two lines
    getline(inFile, file_text);
    getline(inFile, file_text);
    map<int, memoryReference> referenceTable;
    //main loop, goes through each instruction in the text file given
    for (int i = 0; getline(inFile, file_text); i++)
    {
        //first char is read or write, second char is the memory address to read
        char instruction = file_text[0];
        file_text.erase(0, 1); //get rid of instruction and space characters
        int memoryAddress = stoi(file_text);

        memoryReference newReference;
        if (instruction == 'R')
        {
            //add memory address to referenceTable
            newReference.memoryAddress = memoryAddress;
            //calculate mm block that memory address belongs to and add to referenceTable

            int memoryBlock = memoryAddress / blockSize;
            newReference.mmBlock = memoryBlock;
            //calculate cache set that memory address belongs to and add to referenceTable
            newReference.cmSet = mmTable[memoryBlock].index;
            //calculate cache block(s) that memory address possibly belongs to and add to referenceTable
            vector<int> cacheBlocks = possibleBlocks(mmTable[memoryBlock].index, setDegree);
            for (int i = 0; i < cacheBlocks.size(); i++)
            {
                newReference.cmBlock.append(to_string(cacheBlocks[i]));
                if (i != cacheBlocks.size() - 1)
                {
                    newReference.cmBlock.append(" or ");
                }
            }

            //check if the memory address was already in the cache(add hit or miss to referenceTable)
            for (int i = 0; i < cacheBlocks.size(); i++)
            {
                //cout << cacheTable[cacheBlocks[i]].tag << " " << mmTable[memoryBlock].tag << " " << cacheTable[cacheBlocks[i]].validBit << endl;
                if (cacheTable[cacheBlocks[i]].tag == mmTable[memoryBlock].tag && cacheTable[cacheBlocks[i]].validBit == 1)
                {
                    newReference.hitMiss = "hit";
                    //need to change the pos of the cache block in the lru queue
                    for (int i = 0; i < cacheTable[cacheBlocks[0]].lruQueue.size(); i++)
                    {
                        if (cacheTable[cacheBlocks[0]].lruQueue.at(i) == cacheBlocks[i])
                        {
                            cacheTable[cacheBlocks[0]].lruQueue.erase(cacheTable[cacheBlocks[0]].lruQueue.begin() + i);
                            cacheTable[cacheBlocks[0]].lruQueue.push_back(cacheBlocks[i]);
                        }
                    }
                    break; // the value already in the cache so no reason to continue
                }
                else
                {
                    newReference.hitMiss = "miss";
                }
            }
            //update the cache table to reflect added data(only add data if there is a miss)
            if (newReference.hitMiss == "miss")
            {
                bool replacement = false;
                for (int i = 0; i < cacheBlocks.size(); i++)
                {
                    if (cacheTable[cacheBlocks[i]].validBit == 0)
                    {
                        // updateCacheTable(cacheBlocks[i], memoryBlock, mmTable[memoryBlock].tag, cacheTable);
                        cacheTable[cacheBlocks[i]].validBit = 1;
                        cacheTable[cacheBlocks[i]].tag = mmTable[memoryBlock].tag;
                        cacheTable[cacheBlocks[i]].data.append("mm blk # ");
                        cacheTable[cacheBlocks[i]].data.append(to_string(memoryBlock));
                        cacheTable[cacheBlocks[0]].fifoQueue.push_back(cacheBlocks[i]); //push the cache block changed to the set queue
                        cacheTable[cacheBlocks[0]].lruQueue.push_back(cacheBlocks[i]);  //push the cache block changed to the set queue
                        replacement = false;                                            //memory added to cache, no need for replacement
                        break;                                                          //we have added the value to the cache, so no reason to continue
                    }
                    replacement = true; // gone through both possible blocks and didnt add it to the cache
                }

                if (replacement == true)
                {
                    // a replacement is required
                    // LRU = replace block that has not been referenced in the longest time
                    if (replacement_policy == "L")
                    {
                        int cacheReplacement = cacheTable[cacheBlocks[0]].lruQueue.front();
                        cout << "clearing cache block " << cacheReplacement << endl;
                        clearCacheBlock(cacheReplacement, cacheTable);
                        updateCacheTable(cacheReplacement, memoryBlock, mmTable[memoryBlock].tag, cacheTable);
                        cacheTable[cacheBlocks[0]].lruQueue.pop_front();                 //remove the first element from the queue
                        cacheTable[cacheBlocks[0]].lruQueue.push_back(cacheReplacement); //add the new block to the queue
                    }
                    //FIFO implementation
                    if (replacement_policy == "F")
                    {
                        int cacheReplacement = cacheTable[cacheBlocks[0]].fifoQueue.front();
                        cout << "clearing cache block " << cacheReplacement << endl;
                        clearCacheBlock(cacheReplacement, cacheTable);
                        updateCacheTable(cacheReplacement, memoryBlock, mmTable[memoryBlock].tag, cacheTable);
                        cacheTable[cacheBlocks[0]].fifoQueue.pop_front();                 //remove the first element from the queue
                        cacheTable[cacheBlocks[0]].fifoQueue.push_back(cacheReplacement); //add the new block to the queue
                    }
                }
            }
        }
        else
        {
            //write instruction
        }
        referenceTable[i] = newReference;
    }
    printReferenceTable(referenceTable);
    cout << endl
         << endl;
    printCacheTable(cacheTable);

    inFile.close();
}