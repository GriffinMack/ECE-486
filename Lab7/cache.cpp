#include <iostream>
#include <iomanip>
#include <bitset>
#include <fstream>

#include <algorithm>
#include <vector>
#include <map>
#include <deque>

using namespace std;

struct mmBlock
{
    int tag = 0;
    int index = 0;
    int data = 0;
};

struct cacheBlock
{
    int dirtyBit = 0;
    int validBit = 0;
    int tag = 0;
    string data;
    deque<int> fifoQueue; //first block in a cache set will contain the queue for the whole set
    deque<int> lruQueue;
};

struct memoryReference
{
    int memoryAddress = 0;
    int mmBlock = 0;
    int cmSet = 0;
    string cmBlock;
    string hitMiss;
};

int countBits(int block_size)
{
    //counts the bits needed to represent an integer
    int count = 0;
    while (block_size)
    {
        count++;
        block_size = block_size >> 1;
    }
    return count;
}

string toBinary(int n, int tagBits)
{
    string binary;
    int count = 0;
    for (int i = 0; n; i++)
    {
        count++;
        binary.append(to_string(n >> 1));
        n = n >> 1;
    }
    for (int i = 0; i < tagBits - count; i++)
    {
        binary.insert(0, "0");
    }
    return binary;
}

vector<int> possibleBlocks(int set, int setDegree)
{
    //returns possible cache blocks given a cache set and the set degree
    vector<int> possibleBlocks;
    for (int i = 0; i < setDegree; i++)
    {
        possibleBlocks.push_back(set * setDegree + i);
    }
    return possibleBlocks;
}

void clearCacheBlock(int cmBlock, map<int, cacheBlock> &cacheTable)
{
    //clears a given cache block in the cache table
    cacheTable[cmBlock].validBit = 0;
    cacheTable[cmBlock].tag = 0;
    cacheTable[cmBlock].data.erase();
}

void updateCacheTable(int cmBlock, int memoryBlock, int tag, map<int, cacheBlock> &cacheTable)
{
    //given a cache block, memory block, tag, and the cache table, updates the cache table with a new value
    cacheTable[cmBlock].validBit = 1;
    cacheTable[cmBlock].dirtyBit = 0;
    cacheTable[cmBlock].tag = tag;
    cacheTable[cmBlock].data.append("mm blk # ");
    cacheTable[cmBlock].data.append(to_string(memoryBlock));
}

void printReferenceTable(map<int, memoryReference> referenceTable)
{
    cout << "main memory address   "
         << "mm blk #   "
         << "cm set #   "
         << "cm blk #   "
         << "hit/miss" << endl;
    cout << "_______________________________________________________________\n";
    for (int i = 0; i < referenceTable.size(); i++)
    {
        cout << left << setw(22) << referenceTable[i].memoryAddress;
        cout << left << setw(11) << referenceTable[i].mmBlock;
        cout << left << setw(11) << referenceTable[i].cmSet;
        cout << left << setw(11) << referenceTable[i].cmBlock;
        cout << referenceTable[i].hitMiss << endl;
    }
    cout << endl;
}

void printCacheTable(int tagSize, map<int, cacheBlock> cacheTable)
{
    cout << "Cache blk #   "
         << "dirty bit   "
         << "valid bit   "
         << "tag   "
         << "Data" << endl;
    cout << "________________________________________________\n";
    for (int i = 0; i < cacheTable.size(); i++)
    {
        cout << left << setw(14) << i;
        cout << left << setw(12) << cacheTable[i].dirtyBit;
        cout << left << setw(12) << cacheTable[i].validBit;
        if (cacheTable[i].validBit == 1)
        {
            cout << left << setw(3 + tagSize) << toBinary(cacheTable[i].tag, tagSize);
            cout << left << setw(11) << cacheTable[i].data << endl;
        }
        else
        {
            cout << left << setw(3 + tagSize) << "xxx";
            cout << left << setw(11) << "xxx" << endl;
        }
    }
    cout << endl;
}
int main()
{
    int mmSize = 128;
    // cout << "Enter the size of main memory in bytes:";
    // cin >> mm_size;

    int cacheSize = 32;
    // cout << "Enter the size of the cache in bytes:";
    // cin >> cache_size;

    int blockSize = 4;
    // cout << "Enter the cache block/line size:";
    // cin >> block_size;

    int setDegree = 2;
    // cout << "Enter the degree of set-associativity (input n for an n-way set-associative mapping):";
    // cin >> set_degree;

    // // at start up assume lower cm block numbers are LRU than cm blocks with higher numbers.
    string replacement_policy = "F";
    // cout << "Enter the replacement policy (L = LRU, F = FIFO):";
    //cin >> replacement_policy;

    string input_file;
    // cout << "Enter the name of the input file containing the list of memory references generated by the CPU:";
    // cin >> input_file;

    int mmBlocks = mmSize / blockSize;       //max amount of memory blocks
    int cacheBlocks = cacheSize / blockSize; //max amount of cache blocks
    int cacheSets = cacheBlocks / setDegree; //max amount of cache sets

    int offsetBits = countBits(blockSize - 1); //# of bits for offset
    int indexBits = countBits(cacheSets - 1);  //# of bits for the index ()
    //cout << mmBlocks << " " << cacheSets << endl;
    //MAKE SURE THIS ISNT -1
    int tagBits = countBits((mmBlocks / cacheSets) - 1); //#of bits for the tag()
    int totalCacheSize = mmBlocks + 2 + tagBits;         //total cache size in bytes
    int addressLines = indexBits + tagBits + offsetBits; //address lines required (tag + index + offset)

    cout << "Total address lines required = " << addressLines << endl;
    cout << "Number of bits for offset = " << offsetBits << endl;
    cout << "Number of bits for index = " << indexBits << endl;
    cout << "Number of bits for tag = " << tagBits << endl;
    cout << "Total cache size required = " << totalCacheSize << " bytes" << endl;
    cout << endl;

    //create a blank cache table(all values are 0)
    map<int, cacheBlock> cacheTable;
    for (int i = 0; i < cacheBlocks; i++)
    {
        cacheBlock newBlock;
        cacheTable[i] = newBlock;
    }

    //create the main memory table(sets up tag, index and block number)
    map<int, mmBlock> mmTable;
    int tag = 0;
    int index = 0;
    for (int i = 0; i < mmBlocks; i++)
    {
        if (i % cacheSets == 0 && i != 0)
        {
            tag++;
            index = 0;
        }
        mmBlock newBlock;
        newBlock.tag = tag;
        newBlock.index = index;
        mmTable[i] = newBlock;
        index++;
    }

    ifstream inFile("input_file1.txt");
    string file_text;
    map<int, memoryReference> referenceTable; //create a table of references

    //dont really care about the first two lines
    getline(inFile, file_text);
    getline(inFile, file_text);

    //main loop, goes through each instruction in the text file given
    for (int i = 0; getline(inFile, file_text); i++)
    {
        //first char is read or write, second char is the memory address to read/write
        char instruction = file_text[0];
        file_text.erase(0, 1); //get rid of instruction and space characters
        int memoryAddress = stoi(file_text);
        int memoryBlock = memoryAddress / blockSize;

        memoryReference newReference;
        newReference.memoryAddress = memoryAddress;      //add memory address to referenceTable
        newReference.mmBlock = memoryBlock;              //add memory block to referenceTable
        newReference.cmSet = mmTable[memoryBlock].index; //add cache set mm block belongs to to referenceTable

        vector<int> cacheBlocks = possibleBlocks(mmTable[memoryBlock].index, setDegree);
        for (int i = 0; i < cacheBlocks.size(); i++)
        {
            newReference.cmBlock.append(to_string(cacheBlocks[i])); //add cache blocks mm block belongs to
            if (i != cacheBlocks.size() - 1)
            {
                newReference.cmBlock.append(" or ");
            }
        }

        //check if the memory address was already in the cache(add hit or miss to referenceTable)
        for (int i = 0; i < cacheBlocks.size(); i++)
        {
            if (cacheTable[cacheBlocks[i]].tag == mmTable[memoryBlock].tag && cacheTable[cacheBlocks[i]].validBit == 1)
            {
                if (instruction == 'W')
                {
                    cacheTable[cacheBlocks[i]].dirtyBit = 1;
                }
                newReference.hitMiss = "hit";
                break; // the value is already in the cache so no reason to continue
            }
            else
            {
                newReference.hitMiss = "miss";
            }
        }
        //update the cache table to reflect added data(only add data if there is a miss)
        if (newReference.hitMiss == "miss")
        {
            bool replacement = false;
            for (int i = 0; i < cacheBlocks.size(); i++)
            {
                if (cacheTable[cacheBlocks[i]].validBit == 0)
                {
                    // updateCacheTable(cacheBlocks[i], memoryBlock, mmTable[memoryBlock].tag, cacheTable);
                    if (instruction == 'W')
                    {
                        cacheTable[cacheBlocks[i]].dirtyBit = 1;
                    }
                    cacheTable[cacheBlocks[i]].validBit = 1;
                    cacheTable[cacheBlocks[i]].tag = mmTable[memoryBlock].tag;
                    cacheTable[cacheBlocks[i]].data.append("mm blk # ");
                    cacheTable[cacheBlocks[i]].data.append(to_string(memoryBlock));
                    cacheTable[cacheBlocks[0]].fifoQueue.push_back(cacheBlocks[i]); //push the cache block changed to the set queue
                    cacheTable[cacheBlocks[0]].lruQueue.push_back(cacheBlocks[i]);  //push the cache block changed to the set queue
                    replacement = false;                                            //memory added to cache, no need for replacement
                    break;                                                          //we have added the value to the cache, so no reason to continue
                }
                replacement = true; // gone through all possible blocks and didnt add it to the cache
            }

            if (replacement == true)
            {
                // LRU implementation
                if (replacement_policy == "L")
                {
                    int cacheReplacement = cacheTable[cacheBlocks[0]].lruQueue.front();
                    clearCacheBlock(cacheReplacement, cacheTable);
                    updateCacheTable(cacheReplacement, memoryBlock, mmTable[memoryBlock].tag, cacheTable);
                    cacheTable[cacheBlocks[0]].lruQueue.pop_front();                 //remove the first element from the queue
                    cacheTable[cacheBlocks[0]].lruQueue.push_back(cacheReplacement); //add the new block to the queue
                }
                //FIFO implementation
                if (replacement_policy == "F")
                {
                    int cacheReplacement = cacheTable[cacheBlocks[0]].fifoQueue.front();
                    clearCacheBlock(cacheReplacement, cacheTable);
                    updateCacheTable(cacheReplacement, memoryBlock, mmTable[memoryBlock].tag, cacheTable);
                    cacheTable[cacheBlocks[0]].fifoQueue.pop_front();                 //remove the first element from the queue
                    cacheTable[cacheBlocks[0]].fifoQueue.push_back(cacheReplacement); //add the new block to the queue
                }
            }
        }
        else
        {
            for (int i = 0; i < cacheTable[cacheBlocks[0]].lruQueue.size(); i++)
            {
                if (cacheTable[cacheBlocks[0]].lruQueue.at(i) == cacheBlocks[i])
                {
                    cacheTable[cacheBlocks[0]].lruQueue.erase(cacheTable[cacheBlocks[0]].lruQueue.begin() + i);
                    cacheTable[cacheBlocks[0]].lruQueue.push_back(cacheBlocks[i]);
                }
            }
        }
        referenceTable[i] = newReference;
    }
    printReferenceTable(referenceTable);
    printCacheTable(tagBits, cacheTable);
    inFile.close();
}